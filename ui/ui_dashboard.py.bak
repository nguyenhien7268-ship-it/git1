# T√™n file: code6/ui/ui_dashboard.py
# (PHI√äN B·∫¢N ƒê√É FIX: L·ªçc C·∫ßu ƒê·ªÅ kh·ªèi b·∫£ng Th√¥ng 10 K·ª≥)

import datetime
import tkinter as tk
import traceback
from tkinter import messagebox, ttk

try:
    from logic.config_manager import SETTINGS
except ImportError:
    print("L·ªñI: ui_dashboard.py kh√¥ng th·ªÉ import logic.config_manager...")
    
    class FallbackSettings:
        """Fallback settings when config_manager import fails"""
        GAN_DAYS = 15
        HIGH_WIN_THRESHOLD = 47.0
        K2N_RISK_START_THRESHOLD = 4
        FILTER_ENABLED = False
        FILTER_MIN_CONFIDENCE = 0
        FILTER_MIN_AI_PROB = 0
        
        def save_settings(self):
            """Dummy save method for fallback"""
            print("WARNING: Cannot save settings - config_manager not available")
            return True, "Fallback mode"
    
    SETTINGS = FallbackSettings()

# Enhancement 4: Filter threshold constants
# V7.6 IMPROVED: TƒÉng ng∆∞·ª°ng ƒë·ªÉ c·∫£i thi·ªán hi·ªáu qu·∫£ (gi·∫£m t·ªâ l·ªá g√£y)
FILTER_CONFIDENCE_THRESHOLD = 5  # Minimum confidence stars (tƒÉng t·ª´ 4 ‚Üí 5)
FILTER_AI_PROB_THRESHOLD = 60  # Minimum AI probability % (tƒÉng t·ª´ 50 ‚Üí 60)

# Import DB Logic ƒë·ªÉ l·∫•y d·ªØ li·ªáu c·∫ßu
try:
    from logic.db_manager import DB_NAME
    from logic.data_repository import get_managed_bridges_with_prediction
    # --- GEMINI ADDED ---
    from logic.analytics import dashboard_scorer
except ImportError:
    print("L·ªñI: ui_dashboard.py kh√¥ng th·ªÉ import DB logic...")
    DB_NAME = "data/xo_so_prizes_all_logic.db"

    def get_managed_bridges_with_prediction(db_name, current_data=None, only_enabled=True):
        return []


class DashboardWindow(ttk.Frame):
    def __init__(self, app_instance):
        super().__init__(app_instance.notebook, padding=10)

        self.app = app_instance
        self.root = app_instance.root

        self.columnconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)

        self.header_frame = ttk.Frame(self)
        self.header_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)

        self.title_label = ttk.Label(
            self.header_frame, text="ƒêang t·∫£i...", font=("Arial", 16, "bold")
        )
        self.title_label.pack(side=tk.LEFT, padx=(0, 20))

        # Enhancement 4: Smart Filtering controls
        self._create_filter_controls()

        self.refresh_button = ttk.Button(
            self.header_frame, text="L√†m M·ªõi D·ªØ Li·ªáu", command=self.refresh_data
        )
        self.refresh_button.pack(side=tk.RIGHT)

        self.main_analysis_frame = ttk.Frame(self, padding=10)
        self.main_analysis_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)

        # ===================================================================
        # C·∫§U H√åNH LAYOUT (L∆Ø·ªöI 24 C·ªòT)
        # ===================================================================
        
        for i in range(24):
            self.main_analysis_frame.columnconfigure(i, weight=1)

        # H√†ng 0: C√°c b·∫£ng ch√≠nh (Cao h∆°n)
        self.main_analysis_frame.rowconfigure(0, weight=3)
        # H√†ng 1: C√°c b·∫£ng tham kh·∫£o (Th·∫•p h∆°n ch√∫t)
        self.main_analysis_frame.rowconfigure(1, weight=2)

        # ===================================================================
        # T·∫†O C√ÅC B·∫¢NG
        # ===================================================================

        # --- H√ÄNG 0: KHU V·ª∞C QUY·∫æT ƒê·ªäNH ---

        # 1. B·∫£ng Ch·∫•m ƒêi·ªÉm (Chi·∫øm 16/24 c·ªôt = 2/3)
        self._create_top_scores_ui(self.main_analysis_frame)
        self.top_scores_frame.grid(row=0, column=0, columnspan=16, sticky="nsew", padx=5, pady=5)

        # 2. C·∫ßu K2N ƒêang Ch·ªù (Chi·∫øm 8/24 c·ªôt = 1/3)
        self._create_pending_k2n_ui(self.main_analysis_frame)
        self.pending_k2n_frame.grid(row=0, column=16, columnspan=8, sticky="nsew", padx=5, pady=5)

        # --- H√ÄNG 1: KHU V·ª∞C THAM KH·∫¢O ---

        # 3. D·ª± ƒëo√°n AI (5/24 c·ªôt)
        self._create_ai_predictions_ui(self.main_analysis_frame)
        self.ai_predictions_frame.grid(row=1, column=0, columnspan=5, sticky="nsew", padx=5, pady=5)

        # 4. C·∫ßu Th√¥ng 10 K·ª≥ (9/24 c·ªôt - R·ªông nh·∫•t)
        self._create_recent_form_ui(self.main_analysis_frame)
        self.recent_form_frame.grid(row=1, column=5, columnspan=9, sticky="nsew", padx=5, pady=5)

        # 5. Loto V·ªÅ Nhi·ªÅu (5/24 c·ªôt)
        self._create_hot_loto_ui(self.main_analysis_frame)
        self.hot_loto_frame.grid(row=1, column=14, columnspan=5, sticky="nsew", padx=5, pady=5)

        # 6. Vote Statistics (5/24 c·ªôt) - REPLACED L√¥ Gan
        self._create_vote_statistics_ui(self.main_analysis_frame)
        self.vote_statistics_frame.grid(row=1, column=19, columnspan=5, sticky="nsew", padx=5, pady=5)
        
        # --- [M·ªöI] H√ÄNG 2: V√ôNG K·∫æT QU·∫¢ SCORING & C·∫¢NH B√ÅO ---
        self.main_analysis_frame.rowconfigure(2, weight=1) # C·∫•p quy·ªÅn gi√£n d√≤ng cho h√†ng 2
        
        self.result_log_frame = ttk.Labelframe(self.main_analysis_frame, text="üìù K·∫øt Qu·∫£ Ph√¢n T√≠ch & C·∫£nh B√°o (V3.8)")
        self.result_log_frame.grid(row=2, column=0, columnspan=24, sticky="nsew", padx=5, pady=5)
        
        # T·∫°o Widget Text ƒë·ªÉ hi·ªÉn th·ªã
        self.txt_result_log = tk.Text(self.result_log_frame, height=5, font=("Arial", 10))
        self.txt_result_log.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar cho text
        scrollbar_log = ttk.Scrollbar(self.result_log_frame, orient=tk.VERTICAL, command=self.txt_result_log.yview)
        scrollbar_log.pack(side=tk.RIGHT, fill=tk.Y)
        self.txt_result_log.configure(yscrollcommand=scrollbar_log.set)
    # ===================================================================================
    # C√ÅC H√ÄM T·∫†O UI
    # ===================================================================================

    def _create_filter_controls(self):
        """Enhancement 4: Create smart filtering controls"""
        filter_frame = ttk.Frame(self.header_frame)
        filter_frame.pack(side=tk.RIGHT, padx=(10, 10))

        # Filter enabled checkbox
        self.filter_enabled_var = tk.BooleanVar(value=SETTINGS.FILTER_ENABLED)
        filter_check = ttk.Checkbutton(
            filter_frame,
            text="L·ªçc th√¥ng minh",
            variable=self.filter_enabled_var,
            command=self._on_filter_changed
        )
        filter_check.pack(side=tk.LEFT, padx=5)

        # Min confidence filter
        conf_frame = ttk.Frame(filter_frame)
        conf_frame.pack(side=tk.LEFT, padx=5)
        
        self.filter_confidence_var = tk.BooleanVar(
            value=SETTINGS.FILTER_MIN_CONFIDENCE >= FILTER_CONFIDENCE_THRESHOLD
        )
        conf_check = ttk.Checkbutton(
            conf_frame,
            text=f"Ch·ªâ hi·ªán ‚â•{FILTER_CONFIDENCE_THRESHOLD}‚≠ê",
            variable=self.filter_confidence_var,
            command=self._on_filter_changed
        )
        conf_check.pack()

        # Min AI probability filter
        ai_frame = ttk.Frame(filter_frame)
        ai_frame.pack(side=tk.LEFT, padx=5)
        
        self.filter_ai_var = tk.BooleanVar(
            value=SETTINGS.FILTER_MIN_AI_PROB >= FILTER_AI_PROB_THRESHOLD
        )
        ai_check = ttk.Checkbutton(
            ai_frame,
            text=f"Ch·ªâ hi·ªán AI ‚â•{FILTER_AI_PROB_THRESHOLD}%",
            variable=self.filter_ai_var,
            command=self._on_filter_changed
        )
        ai_check.pack()

    def _on_filter_changed(self):
        """Handle filter checkbox changes"""
        # Update SETTINGS
        SETTINGS.FILTER_ENABLED = self.filter_enabled_var.get()
        SETTINGS.FILTER_MIN_CONFIDENCE = (
            FILTER_CONFIDENCE_THRESHOLD if self.filter_confidence_var.get() else 0
        )
        SETTINGS.FILTER_MIN_AI_PROB = (
            FILTER_AI_PROB_THRESHOLD if self.filter_ai_var.get() else 0
        )
        
        # Save preferences
        SETTINGS.save_settings()
        
        # Refresh data to apply filters
        if hasattr(self.app, 'refresh_dashboard'):
            self.app.refresh_dashboard()

    def _create_top_scores_ui(self, parent_frame):
        self.top_scores_frame = ttk.Labelframe(
            parent_frame, text="üèÜ B·∫£ng Ch·∫•m ƒêi·ªÉm T·ªïng L·ª±c (Double-click ƒë·ªÉ xem chi ti·∫øt)"
        )
        tree_frame = ttk.Frame(self.top_scores_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        cols = ("score", "ai", "confidence", "recommendation", "pair", "gan", "reasons")
        self.scores_tree = ttk.Treeview(
            tree_frame, columns=cols, show="headings", height=10
        )
        self.scores_tree.heading("score", text="ƒêi·ªÉm")
        self.scores_tree.heading("ai", text="AI")
        self.scores_tree.heading("confidence", text="‚≠ê")
        self.scores_tree.heading("recommendation", text="Khuy·∫øn Ngh·ªã")
        self.scores_tree.heading("pair", text="C·∫∑p s·ªë")
        self.scores_tree.heading("gan", text="Gan")
        self.scores_tree.heading("reasons", text="L√Ω do (T√≠ch h·ª£p AI)")
        
        self.scores_tree.column("score", width=50, minwidth=50, anchor=tk.E)
        self.scores_tree.column("ai", width=60, minwidth=60, anchor=tk.CENTER)
        self.scores_tree.column("confidence", width=50, minwidth=50, anchor=tk.CENTER)
        self.scores_tree.column("recommendation", width=80, minwidth=80, anchor=tk.CENTER)
        self.scores_tree.column("pair", width=60, minwidth=60, anchor=tk.CENTER)
        self.scores_tree.column("gan", width=50, minwidth=50, anchor=tk.CENTER)
        self.scores_tree.column("reasons", width=380, minwidth=280)
        
        # Thanh cu·ªôn D·ªçc
        v_scrollbar = ttk.Scrollbar(
            tree_frame, orient=tk.VERTICAL, command=self.scores_tree.yview
        )
        v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Thanh cu·ªôn Ngang
        h_scrollbar = ttk.Scrollbar(
            tree_frame, orient=tk.HORIZONTAL, command=self.scores_tree.xview
        )
        h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)

        self.scores_tree.configure(
            yscrollcommand=v_scrollbar.set, 
            xscrollcommand=h_scrollbar.set
        )
        self.scores_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.scores_tree.tag_configure("gan", foreground="red")
        self.scores_tree.tag_configure(
            "top1", background="#D5E8D4", font=("Arial", 10, "bold")
        )
        self.scores_tree.tag_configure("top3", background="#FFF2CC")
        
        # AI color tags
        self.scores_tree.tag_configure("ai_very_high", foreground="#006400", font=("Arial", 9, "bold"))  # Dark green >=70%
        self.scores_tree.tag_configure("ai_high", foreground="#228B22")  # Green >=50%
        self.scores_tree.tag_configure("ai_med", foreground="#DAA520")  # Goldenrod >=30%
        self.scores_tree.tag_configure("ai_low", foreground="#A9A9A9")  # Gray <30%
        
        # NEW: Enhancement 3 - Recommendation color tags
        self.scores_tree.tag_configure("rec_choi", foreground="green", font=("Arial", 9, "bold"))
        self.scores_tree.tag_configure("rec_xem_xet", foreground="#DAA520", font=("Arial", 9))
        self.scores_tree.tag_configure("rec_bo_qua", foreground="gray", font=("Arial", 9))
        
        # (M·ªöI) Bind s·ª± ki·ªán click
        self.scores_tree.bind("<Double-1>", self.on_tree_double_click)

    def _create_ai_predictions_ui(self, parent_frame):
        self.ai_predictions_frame = ttk.Labelframe(
            parent_frame, text="üß† AI (ƒê∆°n)"
        )
        tree_frame = ttk.Frame(self.ai_predictions_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        cols = ("loto", "probability")
        self.ai_tree = ttk.Treeview(
            tree_frame, columns=cols, show="headings", height=8
        )
        self.ai_tree.heading("loto", text="S·ªë")
        self.ai_tree.heading("probability", text="%")
        self.ai_tree.column("loto", width=40, anchor=tk.CENTER)
        self.ai_tree.column("probability", width=50, anchor=tk.E)
        scrollbar = ttk.Scrollbar(
            tree_frame, orient=tk.VERTICAL, command=self.ai_tree.yview
        )
        self.ai_tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.ai_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.ai_tree.tag_configure(
            "top1", background="#D5E8D4", font=("Arial", 9, "bold")
        )

    def _create_recent_form_ui(self, parent_frame):
        self.recent_form_frame = ttk.Labelframe(
            parent_frame, text="üî• Th√¥ng 10 K·ª≥ (>= 5/10)"
        )
        tree_frame = ttk.Frame(self.recent_form_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

        cols = ("name", "wins", "prediction")
        self.recent_form_tree = ttk.Treeview(
            tree_frame, columns=cols, show="headings", height=8
        )

        self.recent_form_tree.heading("name", text="T√™n C·∫ßu")
        self.recent_form_tree.heading("wins", text="Th·∫Øng")
        self.recent_form_tree.heading("prediction", text="D·ª± ƒêo√°n")

        self.recent_form_tree.column("name", width=150, anchor=tk.W)
        self.recent_form_tree.column("wins", width=60, anchor=tk.CENTER)
        self.recent_form_tree.column("prediction", width=60, anchor=tk.CENTER)

        scrollbar = ttk.Scrollbar(
            tree_frame, orient=tk.VERTICAL, command=self.recent_form_tree.yview
        )
        self.recent_form_tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.recent_form_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.recent_form_tree.tag_configure(
            "excellent", background="#D5E8D4", font=("Arial", 9, "bold")
        )
        self.recent_form_tree.tag_configure("good", background="#FFF2CC")
        
        self.recent_form_tree.bind("<Double-1>", self.on_tree_double_click)

    def _create_hot_loto_ui(self, parent_frame):
        self.hot_loto_frame = ttk.Labelframe(
            parent_frame, text="üî• Hot (7 ng√†y)"
        )
        tree_frame = ttk.Frame(self.hot_loto_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        cols = ("loto", "hits")
        self.hot_loto_tree = ttk.Treeview(
            tree_frame, columns=cols, show="headings", height=8
        )
        self.hot_loto_tree.heading("loto", text="S·ªë")
        self.hot_loto_tree.heading("hits", text="Nh√°y")
        self.hot_loto_tree.column("loto", width=40, anchor=tk.CENTER)
        self.hot_loto_tree.column("hits", width=40, anchor=tk.CENTER)
        scrollbar = ttk.Scrollbar(
            tree_frame, orient=tk.VERTICAL, command=self.hot_loto_tree.yview
        )
        self.hot_loto_tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.hot_loto_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    def _create_vote_statistics_ui(self, parent_frame):
        """NEW: Vote Statistics table (replaces L√¥ Gan)"""
        self.vote_statistics_frame = ttk.Labelframe(
            parent_frame, text="üìä Vote (Top)"
        )
        tree_frame = ttk.Frame(self.vote_statistics_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        cols = ("pair", "votes")
        self.vote_tree = ttk.Treeview(
            tree_frame, columns=cols, show="headings", height=8
        )
        self.vote_tree.heading("pair", text="C·∫∑p")
        self.vote_tree.heading("votes", text="Vote")
        self.vote_tree.column("pair", width=50, anchor=tk.CENTER)
        self.vote_tree.column("votes", width=40, anchor=tk.CENTER)
        scrollbar = ttk.Scrollbar(
            tree_frame, orient=tk.VERTICAL, command=self.vote_tree.yview
        )
        self.vote_tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.vote_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Color coding
        self.vote_tree.tag_configure("high", background="#D5E8D4", font=("Arial", 9, "bold"))
        self.vote_tree.tag_configure("medium", background="#FFF2CC")

    def _create_pending_k2n_ui(self, parent_frame):
        self.pending_k2n_frame = ttk.Labelframe(
            parent_frame, text="‚è≥ C·∫ßu K2N ƒêang Ch·ªù (Ch·ªù N2)"
        )
        tree_frame = ttk.Frame(self.pending_k2n_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        cols = ("stl", "streak", "max_lose", "name")
        self.k2n_tree = ttk.Treeview(
            tree_frame, columns=cols, show="headings", height=10
        )
        self.k2n_tree.heading("stl", text="C·∫∑p s·ªë")
        self.k2n_tree.heading("streak", text="Chu·ªói")
        self.k2n_tree.heading("max_lose", text="G√£y Max")
        self.k2n_tree.heading("name", text="T√™n c·∫ßu")
        self.k2n_tree.column("stl", width=50, anchor=tk.CENTER)
        self.k2n_tree.column("streak", width=50, anchor=tk.CENTER)
        self.k2n_tree.column("max_lose", width=50, anchor=tk.CENTER)
        self.k2n_tree.column("name", width=200)
        scrollbar = ttk.Scrollbar(
            tree_frame, orient=tk.VERTICAL, command=self.k2n_tree.yview
        )
        self.k2n_tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.k2n_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.k2n_tree.tag_configure("risk", foreground="red")
        self.k2n_tree.tag_configure("safe", foreground="green")
        self.k2n_tree.bind("<Double-1>", self.on_tree_double_click)

    # --- H√ÄM N·∫†P D·ªÆ LI·ªÜU ---

    def _apply_filters(self, top_scores):
        """Enhancement 4: Apply smart filters to top scores"""
        if not top_scores:
            return top_scores
        
        # If filtering is not enabled, return all scores
        if not SETTINGS.FILTER_ENABLED:
            return top_scores
        
        filtered = []
        min_confidence = SETTINGS.FILTER_MIN_CONFIDENCE
        min_ai_prob = SETTINGS.FILTER_MIN_AI_PROB / 100.0  # Convert to 0-1 range
        
        for item in top_scores:
            # Check confidence filter (number of sources)
            sources = item.get("sources", 0)
            if min_confidence > 0 and sources < min_confidence:
                continue
            
            # Check AI probability filter
            ai_prob = item.get("ai_probability", 0.0)
            if min_ai_prob > 0 and ai_prob < min_ai_prob:
                continue
            
            filtered.append(item)
        
        return filtered

    def clear_data(self):
        self.title_label.config(text="ƒêang t·∫£i...")
        for tree in [
            self.scores_tree,
            self.hot_loto_tree,
            self.vote_tree,  # CHANGED: vote_tree instead of gan_tree
            self.k2n_tree,
            self.ai_tree,
            self.recent_form_tree,
        ]:
            try:
                for item in tree.get_children():
                    tree.delete(item)
            except Exception as e:
                print(f"L·ªói khi x√≥a tree {tree.winfo_name()}: {e}")

    def populate_data(
        self,
        next_ky,
        stats,
        n_days_stats,
        consensus,
        high_win,
        pending_k2n,
        gan_stats,
        top_scores,
        top_memory_bridges,
        ai_predictions,
    ):

        try:
            self.clear_data()

            today = datetime.datetime.now().strftime("%d/%m/%Y %H:%M")
            self.title_label.config(
                text=f"B·∫£ng Quy·∫øt ƒê·ªãnh T·ªëi ∆Øu - {next_ky} (C·∫≠p nh·∫≠t: {today})"
            )

            # Enhancement 4: Apply smart filters if enabled
            filtered_top_scores = self._apply_filters(top_scores)

            # N·∫°p B·∫£ng 1: Ch·∫•m ƒêi·ªÉm
            self._populate_top_scores(filtered_top_scores)

            # N·∫°p B·∫£ng 2: C·∫ßu K2N ƒêang Ch·ªù
            self._populate_pending_k2n(pending_k2n)

            # N·∫°p B·∫£ng 3: D·ª± ƒëo√°n AI
            self._populate_ai_predictions(ai_predictions)

            # N·∫°p B·∫£ng 4: Phong ƒê·ªô 10 K·ª≥
            try:
                # S·ª≠ d·ª•ng h√†m m·ªõi v·ªõi t√≠nh to√°n d·ª± ƒëo√°n t·ª± ƒë·ªông
                all_bridges = get_managed_bridges_with_prediction(
                    DB_NAME, 
                    current_data=self.app.all_data_ai if hasattr(self.app, 'all_data_ai') else None,
                    only_enabled=True
                )
                good_bridges = []
                for b in all_bridges:
                    # [CLEAN CODE FIX] Filter out DE bridges to avoid pollution in Loto table
                    # Ch·ªâ l·∫•y c·∫ßu L√¥, b·ªè qua c√°c type b·∫Øt ƒë·∫ßu b·∫±ng "DE" (DE_DYNAMIC, DE_SET,...)
                    bridge_type = str(b.get("type", "")).upper()
                    if bridge_type.startswith("DE"):
                        continue 

                    recent_wins = b.get("recent_win_count_10", 0)
                    if isinstance(recent_wins, str):
                        try:
                            recent_wins = int(recent_wins)
                        except ValueError:
                            recent_wins = 0
                    if recent_wins >= 5:
                        good_bridges.append(b)

                good_bridges.sort(key=lambda x: x.get("recent_win_count_10", 0), reverse=True)
                self._populate_recent_form(good_bridges)

            except Exception as e:
                print(f"L·ªói khi l·∫•y/l·ªçc c·∫ßu phong ƒë·ªô: {e}")

            # N·∫°p B·∫£ng 5: Loto V·ªÅ Nhi·ªÅu
            self.hot_loto_frame.config(text=f"üî• Hot ({n_days_stats} ng√†y)")
            self._populate_hot_loto(stats)

            # N·∫°p B·∫£ng 6: Vote Statistics (REPLACED L√¥ Gan)
            self._populate_vote_statistics(consensus)

            # N·∫°p B·∫£ng 7: K·∫øt qu·∫£ ph√¢n t√≠ch v√† c·∫£nh b√°o
            # --- GEMINI FIX: HI·ªÇN TH·ªä PH√ÇN T√çCH NGAY L·∫¨P T·ª®C ---
            # S·ª≠ d·ª•ng ngay top_scores v√† gan_stats ƒë√£ c√≥ s·∫µn ƒë·ªÉ hi·ªÉn th·ªã
            # Kh√¥ng c·∫ßn ch·∫°y l·∫°i lu·ªìng t√≠nh to√°n (threading) g√¢y ch·∫≠m tr·ªÖ
            if hasattr(self, '_update_ui_scoring_results'):
                self._update_ui_scoring_results(top_scores, gan_stats)
            # ---------------------------------------------------


        except Exception as e:
            messagebox.showerror(
                "L·ªói N·∫°p D·ªØ Li·ªáu Dashboard",
                f"L·ªói chi ti·∫øt: {e}\n{traceback.format_exc()}",
                parent=self,
            )

    # ===================================================================================
    # C√ÅC H√ÄM N·∫†P D·ªÆ LI·ªÜU CHI TI·∫æT
    # ===================================================================================

    def _populate_top_scores(self, top_scores):
        if not top_scores:
            self.scores_tree.insert(
                "", tk.END, values=("N/A", "", "", "", "N/A", "", "Kh√¥ng c√≥ c·∫∑p n√†o")
            )
            return
        for i, item in enumerate(top_scores[:40]):
            tags = ()
            if item["is_gan"]:
                tags += ("gan",)
            if i == 0:
                tags += ("top1",)
            elif i < 3:
                tags += ("top3",)
            
            # IMPROVED: Show gan loto with days (e.g., "38(8N)")
            gan_text = ""
            if item["is_gan"]:
                gan_loto = item.get("gan_loto", "")
                if gan_loto:
                    gan_text = f"{gan_loto}({item['gan_days']}N)"
                else:
                    gan_text = f"{item['gan_days']}N"
            
            # NEW: Format AI column with icon and percentage
            ai_prob = item.get("ai_probability", 0.0)
            ai_text = ""
            if ai_prob > 0:
                ai_text = f"ü§ñ{int(ai_prob * 100)}"
                # Add AI color tag based on probability
                if ai_prob >= 0.70:
                    tags += ("ai_very_high",)
                elif ai_prob >= 0.50:
                    tags += ("ai_high",)
                elif ai_prob >= 0.30:
                    tags += ("ai_med",)
                else:
                    tags += ("ai_low",)
            
            # NEW: Enhancement 3 - Confidence stars (‚≠ê)
            # IMPROVED: Compact display - show number instead of repeated stars
            sources = item.get("sources", 0)
            confidence_text = f"{sources}‚≠ê" if sources > 0 else ""
            
            # NEW: Enhancement 3 - Recommendation text and color
            recommendation = item.get("recommendation", "B·ªé QUA")
            if recommendation == "CH∆†I":
                tags += ("rec_choi",)
            elif recommendation == "XEM X√âT":
                tags += ("rec_xem_xet",)
            else:
                tags += ("rec_bo_qua",)
            
            self.scores_tree.insert(
                "",
                tk.END,
                values=(
                    item["score"],
                    ai_text,
                    confidence_text,
                    recommendation,
                    item["pair"],
                    gan_text,
                    item["reasons"],
                ),
                tags=tags,
            )

    def _populate_pending_k2n(self, pending_k2n):
        if not pending_k2n:
            self.k2n_tree.insert(
                "", tk.END, values=("(N/A)", "", "", "Kh√¥ng c√≥ c·∫ßu K2N n√†o ch·ªù")
            )
            return
        try:
            # L·ªçc: Ch·ªâ l·∫•y c·∫ßu ƒëang th·ª±c s·ª± ch·ªù N2 (is_n2 = True)
            filtered_items = [
                (name, data) for name, data in pending_k2n.items()
                if data.get("is_n2", True)
            ]

            sorted_k2n = sorted(
                filtered_items,
                key=lambda item: (
                    int(str(item[1]["streak"]).split(" ")[0]),
                    -int(item[1].get("max_lose", 99)),
                ),
                reverse=True,
            )
        except Exception:
            sorted_k2n = list(pending_k2n.items())
            
        risk_threshold = SETTINGS.K2N_RISK_START_THRESHOLD
        
        if not sorted_k2n:
             self.k2n_tree.insert(
                "", tk.END, values=("Kh√¥ng c√≥ c·∫ßu N2", "", "", "")
            )
             
        for bridge_name, data in sorted_k2n:
            stl, streak, max_lose = data["stl"], data["streak"], data.get("max_lose", 0)
            tags = ()
            if max_lose > risk_threshold:
                tags = ("risk",)
            elif max_lose < risk_threshold:
                tags = ("safe",)
            self.k2n_tree.insert(
                "",
                tk.END,
                values=(stl, streak, f"{max_lose} l·∫ßn", bridge_name),
                tags=tags,
            )

    def _populate_ai_predictions(self, ai_predictions):
        if not ai_predictions:
            self.ai_tree.insert("", tk.END, values=("(N/A)", "Vui l√≤ng Hu·∫•n luy·ªán AI"))
            return
        for i, pred in enumerate(ai_predictions[:20]):
            loto = pred["loto"]
            prob = pred["probability"]
            tags = ()
            if i == 0:
                tags = ("top1",)
            elif i < 5:
                tags = ("top5",)
            self.ai_tree.insert("", tk.END, values=(loto, f"{prob:.2f}%"), tags=tags)

    def _populate_recent_form(self, bridges):
        if not bridges:
            self.recent_form_tree.insert(
                "", tk.END, values=("Kh√¥ng c√≥ c·∫ßu n√†o >= 5/10", "", "")
            )
            return

        for b in bridges:
            wins = b.get("recent_win_count_10", 0)
            pred = b.get("next_prediction_stl", "N/A")
            
            tags = ()
            if wins >= 8:
                tags = ("excellent",)
            elif wins >= 6:
                tags = ("good",)
                
            self.recent_form_tree.insert(
                "",
                tk.END,
                values=(
                    b["name"],
                    f"{wins}/10",
                    pred
                ),
                tags=tags
            )

    def _populate_hot_loto(self, stats):
        if not stats:
            self.hot_loto_tree.insert("", tk.END, values=("(N/A)", ""))
            return
        for loto, hits, days in stats:
            self.hot_loto_tree.insert("", tk.END, values=(loto, hits))

    def _populate_vote_statistics(self, consensus):
        """NEW: Populate vote statistics (replaces gan loto)"""
        if not consensus:
            self.vote_tree.insert("", tk.END, values=("(N/A)", ""))
            return
        # consensus is a list of tuples: (pair_key, count, sources_str)
        for pair_key, count, _ in consensus[:20]:  # Show top 20
            tags = ()
            if count >= 10:
                tags = ("high",)
            elif count >= 5:
                tags = ("medium",)
            self.vote_tree.insert("", tk.END, values=(pair_key, f"x{count}"), tags=tags)

    # ===================================================================================
    # H√ÄM T∆Ø∆†NG T√ÅC
    # ===================================================================================

    def _refresh_data_old(self):
        self.app.logger.log(
            "\n--- (L√†m M·ªõi) B·∫Øt ƒë·∫ßu ch·∫°y l·∫°i B·∫£ng Quy·∫øt ƒê·ªãnh T·ªëi ∆Øu ---"
        )
        self.app.run_decision_dashboard()

    def on_tree_double_click(self, event):
        try:
            item_id = event.widget.focus()
            if not item_id:
                return
            item = event.widget.item(item_id)
            values = item["values"]
            bridge_name = ""

            # 1. Click v√†o C·∫ßu K2N
            if event.widget == self.k2n_tree:
                bridge_name = values[3]
                if bridge_name:
                    self.app.trigger_bridge_backtest(bridge_name)

            # 2. Click v√†o Phong ƒê·ªô C·∫ßu
            elif event.widget == self.recent_form_tree:
                bridge_name = values[0]
                if bridge_name:
                    self.app.trigger_bridge_backtest(bridge_name)

            # 3. (M·ªöI) Click v√†o B·∫£ng ƒêi·ªÉm -> Hi·ªÉn th·ªã Popup Chi ti·∫øt L√Ω do
            elif event.widget == self.scores_tree:
                # values = (Score, AI, Confidence, Recommendation, Pair, Gan, Reasons)
                # After V7.7: Added AI (index 1) and Confidence (index 2) columns
                score = values[0]
                ai_text = values[1]  # Already formatted as "ü§ñ75" or empty
                confidence = values[2]
                recommendation = values[3]
                pair = values[4]
                gan_text = values[5]
                reasons_raw = values[6]

                # Format l·∫°i l√Ω do: Xu·ªëng d√≤ng m·ªói khi g·∫∑p d·∫•u ph·∫©y
                reasons_formatted = reasons_raw.replace(", ", "\n- ")
                
                # Format AI display - ai_text is already formatted with emoji and percentage
                ai_display = f"{ai_text}%" if ai_text else "N/A"
                
                info_text = (
                    f"C·∫∑p s·ªë: {pair}\n"
                    f"T·ªïng ƒëi·ªÉm: {score}\n"
                    f"AI: {ai_display}\n"
                    f"‚≠ê Confidence: {confidence}\n"
                    f"Khuy·∫øn ngh·ªã: {recommendation}\n"
                    f"T√¨nh tr·∫°ng Gan: {gan_text if gan_text else 'Kh√¥ng gan'}\n\n"
                    f"=== CHI TI·∫æT L√ù DO ===\n"
                    f"- {reasons_formatted}"
                )
                
                messagebox.showinfo("Chi Ti·∫øt ƒê√°nh Gi√°", info_text, parent=self)

        except Exception as e:
            print(f"L·ªói double-click: {e}")
    
    # [TH√äM M·ªöI HO·∫∂C THAY TH·∫æ] H√†m x·ª≠ l√Ω n√∫t Ph√¢n T√≠ch
    # L∆∞u √Ω: B·∫°n c·∫ßn t·∫°o m·ªôt n√∫t "Ph√¢n T√≠ch L√¥ Scoring" ri√™ng ho·∫∑c t√≠ch h·ª£p v√†o n√∫t "L√†m M·ªõi D·ªØ Li·ªáu"
    # N·∫øu t√≠ch h·ª£p v√†o n√∫t Refresh:
    def refresh_data(self):
        self.app.logger.log("\n--- (L√†m M·ªõi) B·∫Øt ƒë·∫ßu ch·∫°y l·∫°i B·∫£ng Quy·∫øt ƒê·ªãnh T·ªëi ∆Øu ---")
        
        # 1. K√≠ch ho·∫°t lu·ªìng n·∫°p d·ªØ li·ªáu c≈© (Ch·∫°y ng·∫ßm)
        self.app.run_decision_dashboard()
        
        # 2. [FIX] Thay v√¨ ch·∫°y ngay, ta chuy·ªÉn sang ch·∫ø ƒë·ªô "Ch·ªù d·ªØ li·ªáu"
        self.title_label.config(text="‚è≥ ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu...")
        
        # X√≥a log c≈© ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt ƒëang x·ª≠ l√Ω
        if hasattr(self, 'txt_result_log'):
            self.txt_result_log.delete("1.0", tk.END)
            self.txt_result_log.insert("1.0", "‚è≥ ƒêang ƒë·ª£i d·ªØ li·ªáu n·∫°p t·ª´ Database...")
            
        # B·∫Øt ƒë·∫ßu ch·ªù (Check m·ªói 500ms)
        self._wait_for_data_and_run_scoring()

    # [TH√äM H√ÄM M·ªöI N√ÄY V√ÄO D∆Ø·ªöI refresh_data]
    def _wait_for_data_and_run_scoring(self, attempt=0):
        """
        C∆° ch·∫ø 'Polling': Ki·ªÉm tra li√™n t·ª•c xem d·ªØ li·ªáu ƒë√£ v·ªÅ ch∆∞a.
        Timeout: 10 gi√¢y (20 l·∫ßn x 500ms).
        """
        # Ki·ªÉm tra: App ƒë√£ c√≥ d·ªØ li·ªáu ch∆∞a?
        if hasattr(self.app, 'all_data_ai') and self.app.all_data_ai:
            # ‚úÖ D·ªØ li·ªáu ƒë√£ v·ªÅ -> K√≠ch ho·∫°t Scoring Engine ngay!
            self.run_lo_scoring_analysis()
        else:
            # ‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu
            if attempt < 60: # [ƒê√É S·ª¨A] TƒÉng l√™n 30 gi√¢y (60 * 0.5s) ƒë·ªÉ ch·ªù n·∫°p DB l·ªõn
                # ƒê·ª£i 0.5 gi√¢y r·ªìi ki·ªÉm tra l·∫°i (ƒë·ªá quy)
                self.after(500, lambda: self._wait_for_data_and_run_scoring(attempt + 1))
            else:
                # Qu√° h·∫°n 10 gi√¢y m√† v·∫´n ch∆∞a c√≥ d·ªØ li·ªáu -> B√°o l·ªói th·∫≠t
                self.title_label.config(text="‚ö†Ô∏è L·ªói n·∫°p d·ªØ li·ªáu")
                if hasattr(self, 'txt_result_log'):
                    self.txt_result_log.delete("1.0", tk.END)
                    self.txt_result_log.insert("1.0", "‚ö†Ô∏è Qu√° th·ªùi gian ch·ªù (Timeout). D·ªØ li·ªáu ch∆∞a ƒë∆∞·ª£c n·∫°p.\nüëâ Vui l√≤ng ki·ªÉm tra l·∫°i File d·ªØ li·ªáu g·ªëc ho·∫∑c Database.")

    def run_lo_scoring_analysis(self):
        """Ch·∫°y Scoring Engine L√¥ V3.8 (GEMINI FIX 2 - Correct Data Path)"""
        
        # --- 1. T√åM D·ªÆ LI·ªÜU (QUAN TR·ªåNG: Qu√©t c·∫£ App v√† Controller) ---
        all_data = None
        
        # C√°ch 1: T√¨m trong App (C≈©)
        if hasattr(self.app, 'all_data_ai') and self.app.all_data_ai:
            all_data = self.app.all_data_ai
            
        # C√°ch 2: T√¨m trong Controller (Chu·∫©n MVC)
        if not all_data and hasattr(self.app, 'controller'):
            if hasattr(self.app.controller, 'all_data_ai') and self.app.controller.all_data_ai:
                all_data = self.app.controller.all_data_ai
            
        # N·∫øu qu√©t c·∫£ 2 n∆°i v·∫´n kh√¥ng th·∫•y -> B√°o l·ªói cho ng∆∞·ªùi d√πng bi·∫øt
        if not all_data:
            if hasattr(self, 'txt_result_log'):
                self.txt_result_log.delete("1.0", tk.END)
                self.txt_result_log.insert("1.0", "‚ö†Ô∏è KH√îNG T√åM TH·∫§Y D·ªÆ LI·ªÜU.\nüëâ Vui l√≤ng b·∫•m n√∫t 'L√†m M·ªõi D·ªØ Li·ªáu' (G√≥c tr√™n ph·∫£i) ƒë·ªÉ n·∫°p l·∫°i t·ª´ Database.")
                # Force update ƒë·ªÉ hi·ªán th√¥ng b√°o ngay
                self.txt_result_log.update_idletasks()
            return

        # --- 2. C·∫¨P NH·∫¨T GIAO DI·ªÜN ---
        if hasattr(self, 'txt_result_log'):
            self.txt_result_log.delete("1.0", tk.END)
            msg = f"‚è≥ ƒêang ph√¢n t√≠ch {len(all_data)} k·ª≥ d·ªØ li·ªáu (Scoring V3.8)...\n"
            self.txt_result_log.insert("1.0", msg)
            self.txt_result_log.update_idletasks()

        self.title_label.config(text="ƒêang ch·∫°y Scoring L√¥...")
        
        # --- 3. LU·ªíNG X·ª¨ L√ù (THREAD) ---
        def run_thread():
            try:
                # L·∫•y ng√†y m·ªõi nh·∫•t
                day_index = len(all_data) - 1
                
                # G·ªåI TR·ª∞C TI·∫æP LOGIC (B·ªè qua Service ƒë·ªÉ tr√°nh l·ªói)
                features = dashboard_scorer.prepare_daily_features(all_data, day_index)
                
                if not features:
                    self.after(0, lambda: self.txt_result_log.insert(tk.END, "\n‚ùå L·ªói: Kh√¥ng t·∫°o ƒë∆∞·ª£c features (D·ªØ li·ªáu qu√° ng·∫Øn?)."))
                    return

                scores = dashboard_scorer.get_top_scored_pairs(
                    features["stats_n_day"],
                    features["consensus"],
                    features["high_win"],
                    features["pending_k2n"],
                    features["gan_stats"],
                    features["top_memory"],
                    features.get("ai_predictions"),
                    features.get("recent_data")
                )
                
                gan_stats = features["gan_stats"]
                
                # Update UI (Chuy·ªÉn v·ªÅ lu·ªìng ch√≠nh)
                self.after(0, lambda: self._update_ui_scoring_results(scores, gan_stats))
                
            except Exception as e:
                print(f"L·ªói Scoring Thread: {e}")
                import traceback
                traceback.print_exc()
                self.after(0, lambda: self.txt_result_log.insert(tk.END, f"\n‚ùå Exception: {str(e)}"))

        import threading
        threading.Thread(target=run_thread, daemon=True).start()

    def _update_ui_scoring_results(self, scores, gan_stats):
        """Hi·ªÉn th·ªã k·∫øt qu·∫£ v√†o Text Box m·ªõi"""
        self.title_label.config(text=f"ƒê√£ c·∫≠p nh·∫≠t: {datetime.datetime.now().strftime('%H:%M:%S')}")
        
        # X√≥a n·ªôi dung c≈©
        self.txt_result_log.delete("1.0", tk.END)
        
        # 1. Hi·ªÉn th·ªã Top 10
        if scores:
            msg = "üèÜ TOP 10 L√î ƒêI·ªÇM CAO (SCORING V3.8):\n"
            # L·∫•y top 10
            top_10 = scores[:10]
            # Chia th√†nh 2 d√≤ng cho g·ªçn
            row1 = " | ".join([f"{num} ({score:.1f}ƒë)" for num, score in top_10[:5]])
            row2 = " | ".join([f"{num} ({score:.1f}ƒë)" for num, score in top_10[5:]])
            
            msg += f"   {row1}\n   {row2}\n"
            self.txt_result_log.insert(tk.END, msg)
            
            # T√¥ m√†u ti√™u ƒë·ªÅ
            self.txt_result_log.tag_add("title", "1.0", "1.end")
            self.txt_result_log.tag_config("title", foreground="blue", font=("Arial", 10, "bold"))
        else:
            self.txt_result_log.insert(tk.END, "‚ö†Ô∏è Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√≠nh ƒëi·ªÉm.\n")

        # 2. C·∫£nh b√°o L√¥ Gan
        dangerous_gan = [item for item in gan_stats if item.get('so_ngay_gan', 0) > 15]
        if dangerous_gan:
            gan_msg = "\n‚õî C·∫¢NH B√ÅO L√î GAN (>15 ng√†y - N√äN TR√ÅNH):\n"
            gan_nums = [f"{i.get('so')} ({i.get('so_ngay_gan')}d)" for i in dangerous_gan]
            gan_msg += "   " + ", ".join(gan_nums)
            
            # Ch√®n v√†o cu·ªëi
            self.txt_result_log.insert(tk.END, gan_msg)
            
            # T√¥ m√†u ƒë·ªè cho c·∫£nh b√°o
            end_index = self.txt_result_log.index("end-1c")
            start_index = self.txt_result_log.search("‚õî", "1.0", tk.END)
            if start_index:
                self.txt_result_log.tag_add("warning", start_index, end_index)
                self.txt_result_log.tag_config("warning", foreground="red", font=("Arial", 10, "bold"))